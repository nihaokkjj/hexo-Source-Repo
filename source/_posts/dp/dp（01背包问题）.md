---
abbrlink: '0'
date: 2025-05-01 13:59:06
title:
tags:
---

# 1. 题目介绍
有 N件物品和一个容量为 V的背包，每件物品有各自的价值且只能被选择一次，要求在有限的背包容量下，装入的物品总价值最大。

「0-1 背包」是较为简单的动态规划问题，也是其余背包问题的基础。

动态规划是不断决策求最优解的过程，「0-1 背包」即是不断对第 i个物品的做出决策，「0-1」正好代表不选与选两种决定。

**理解  ： for循环中，代表背包剩余体积的j不断增大， 代表遍历层数的i也增大
每一次判断后，f[i][j]代表当前当背包容量为j时，对于第1 到 第  i 个物品中，背包所能装的最优解**
# 2. 题解代码（C++）
## 2.1 版本1 二维
（1）状态f[i][j]定义：前 i个物品，背包容量 j 下的最优解（最大价值）：

当前的状态依赖于之前的状态，可以理解为从初始状态f |0] | 0] = 0开始决策，有 N件物品，则需要 N次决 策，每一次对第 i件物品的决策，状态f[i][j]不断由之前的状态更新而来。
（2）当前背包容量不够（j < v[i]），没得选，因此前 i个物品最优解即为前 i−1个物品最优解：
![[Pasted image 20241205165854.png]]
对应代码：
~~~
f[i][j] = f[i - 1][j]。
~~~
（3）当前背包容量够，可以选，因此需要决策选与不选第 i个物品：

选：
~~~
f[i][j] = f[i - 1][j - v[i]] + w[i]。
~~~
不选：f[i][j] = f[i - 1][j] 。
我们的决策是如何取到最大价值，因此以上两种情况取 max() 。
代码如下：
~~~
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 1005;
int v[MAXN];    // 体积
int w[MAXN];    // 价值 
int f[MAXN][MAXN];  // f[i][j], j体积下前i个物品的最大价值 

int main() 
{
    int n, m;   
    cin >> n >> m;
    for(int i = 1; i <= n; i++) 
        cin >> v[i] >> w[i];

    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= m; j++)
        {
            //  当前背包容量装不进第i个物品，则价值等于前i-1个物品
            if(j < v[i]) 
                f[i][j] = f[i - 1][j];
            // 能装，需进行决策是否选择第i个物品
            else    
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
        }           

    cout << f[n][m] << endl;

    return 0;
}
~~~
## 2.2 版本2 一维
将状态f[i][j]优化到一维f[j]，实际上只需要做一个等价变形。

为什么可以这样变形呢？我们定义的状态f[i][j]可以求得任意合法的i与j最优解，但题目只需要求得最终状态f[n][m]，因此我们只需要一维的空间来更新状态。

（1）状态f[j]定义：N件物品，背包容量j下的最优解。

（2）注意枚举背包容量j必须从m开始。

（3）为什么一维情况下枚举背包容量需要逆序？在二维情况下，状态f[i][j]是由上一轮i - 1的状态得来的，f[i][j]与f[i - 1][j]是独立的。而优化到一维后，如果我们还是正序，则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i-1轮的状态却用的是第i轮的状态。

（4）例如，一维状态第i轮对体积为 3的物品进行决策，则f[7]由f[4]更新而来，这里的f[4]正确应该是f[i - 1][4]，但从小到大枚举j这里的f[4]在第i轮计算却变成了f[i][4]。当逆序枚举背包容量j时，我们求f[7]同样由f[4]更新，但由于是逆序，这里的f[4]还没有在第i轮计算，所以此时实际计算的f[4]仍然是f[i - 1][4]。

（5）简单来说，一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。

状态转移方程为：f[j] = max(f[j], f[j - v[i]] + w[i] 。
~~~
for(int i = 1; i <= n; i++) 
    for(int j = m; j >= 0; j--)
    {
        if(j < v[i]) 
            f[i][j] = f[i - 1][j];  // 优化前
            f[j] = f[j];            // 优化后，该行自动成立，可省略。
        else    
            f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);  // 优化前
            f[j] = max(f[j], f[j - v[i]] + w[i]);                   // 优化后
    }   
~~~ 
实际上，只有当枚举的背包容量 >= v[i] 时才会更新状态，因此我们可以修改循环终止条件进一步优化。
~~~
for(int i = 1; i <= n; i++)
{
    for(int j = m; j >= v[i]; j--)  
        f[j] = max(f[j], f[j - v[i]] + w[i]);
} 
~~~
关于状态f[j]的补充说明
二维下的状态定义f[i][j]是前 i件物品，背包容量 j 下的最大价值。一维下，少了前 i 件物品这个维度，我们的代码中决策到第 i 件物品（循环到第i轮），f[j]就是前i轮已经决策的物品且背包容量 j下的最大价值。

因此当执行完循环结构后，由于已经决策了所有物品，f[j]就是所有物品背包容量 j 下的最大价值。即一维f[j]等价于二维f[n][j]。

## 2.3 版本3 优化输入
我们注意到在处理数据时，我们是一个物品一个物品，一个一个体积的枚举。

因此我们可以不必开两个数组记录体积和价值，而是边输入边处理。
~~~
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 1005;
int f[MAXN];  // 

int main() 
{
    int n, m;   
    cin >> n >> m;

    for(int i = 1; i <= n; i++) {
        int v, w;
        cin >> v >> w;      // 边输入边处理
        for(int j = m; j >= v; j--)
            f[j] = max(f[j], f[j - v] + w);
    }

    cout << f[m] << endl;

    return 0;
}
~~~
## 记忆化数组加dfs
~~~
#include<bits/stdc++.h>  
  
using namespace std;  
  
const int MAXN = 1005;  
int n, m;  
int v[MAXN];    // 体积  
int w[MAXN];    // 价值  
int f[MAXN][MAXN], mem[MAXN][MAXN]; // f[i][j], j体积下前i个物品的最大价值  
  
int dfs(int x, int j)  
{  
    if (mem[x][j]) return mem[x][j];  //之前已经遍历过，直接返回
  
    int sum = 0;  //便于赋值给记忆化数组
    if (x > n) return sum;  
    else  
    {  
        if (j < v[x])  
        {  
            sum = dfs(x + 1, j);  
        }  
        else  
        {  
            sum = max(dfs(x + 1, j), dfs(x + 1,j - v[x]) + w[x]);  
        }  
    }  
    mem[x][j] = sum;  
    return sum;  
}
~~~